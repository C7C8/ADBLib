To Implement:

Tier II
	-OutputEngine
		-Singleton
		-Manages motors and pneumatics - stuff should preferablly be accessed through here
			-Should be SIMPLE to use - no overly complicated function calls for global hardware stuff
		-Should have some way of recieving information from ConfigLoader, so output settings (including PID) can be done without manually setting them in the 
		-Can return SimplePneumatics
		-Can return SimpleMotors
		-Can return PWM/CAN motors
		-Can return Double/Single solenoids
	-ConfigLoader
		-Loads config from an XML file or a multiline-string
		-Singleton, allows any given part of the program to grab config settings
	-FiniteStateMachine
		-Core FSM functionality (states, transitions, etc)
		-"Blip" state support? Would be an incredibly useful anti-kludging tool.
	-FSMState
		-Core FSM state functionality
		-Some way of holding FSM-object-dependent information?
		-Substate support? (probably a class that inherits FSMState)
	-FSMTransition
		-Core FSM transition functionality
		-Might have to be some kind of special handeling for blip states
	-Robot Positioning System
		-Uses the internal accelerometer and an external gyroscope to get robot position relative to the start position.
	-Vision
		-Vision switching of some kind
			-Preferably a "switch to this camera" or "switch to that camera" thing
			-Needs a getImage() function that returns an image regardless of what camera is active.
		-Needs some sort of robust system for getting an image from any camera and putting one to the dashboard - maybe an automatic dashboard push, if enabled.
Tier III
	-RoboRadar
		-Uses one or more rotating ultrasonic sensors to scan the environmap and return some form of array containing a map of the nearby area.
		-Could be used for autonomous or as a neat way for drivers to drive around better.
		-Uses triangulation. Needs precise measurement information on positioning and rotation.
		-Maybe PID for positioning, maybe just a "here's my measurement, here's the angle it was taken at"-type thing.